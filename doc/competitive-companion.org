#+TITLE: Competitive Companion
:PREAMBLE:
#+macro: year (eval (format-time-string "%Y"))

#+SUBTITLE: Competitive Companion integration for Emacs
#+AUTHOR: Luis Higino
#+EMAIL: luis.higino@dcc.ufmg.br
#+DATE: 2024-{{{year}}}
#+LANGUAGE: en

#+TEXINFO_FILENAME: competitive-companion.info
#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Competitive Companion: (competitive-companion).
#+TEXINFO_DIR_DESC: Competitive Companion integration for Emacs.

#+OPTIONS: H:4 num:t toc:t

This plugin provides an Emacs interface to interact with the Competitive Companion browser extension. It also provides some commands to speed up the coding-compiling-test loop during online contests

#+texinfo: @insertcopying
:END:

* Introduction

This plugin provides an Emacs interface to interact with the [[https://github.com/jmerle/competitive-companion][Competitive Companion browser extension]]. It also provides some commands to speed up the coding-compiling-test loop during online contests.

The package is designed to be minimalistic and as non-intrusive as possible, while still providing some level of convenience. The idea is that during an online contest, you turn on the global minor mode. Then, when you read a problem with the browser extension, Emacs will automatically download the test cases to temporary files, without cluttering your folders, and generate an implementation file using your preferred language and template in the contest's folder. When you are done implementing the code and compiling it, the package provides an interactive command that runs the program against the downloaded test cases. Then, if all outputs matched, it just lets you know in the minibuffer. Otherwise, an special buffer pops up with only the failed test cases.

* Installation

This package is currently only available through the GitHub repository. Installation examples in some common settings are provided below.

** Doom Emacs

Add this to =$DOOMDIR/packages.el=:

#+begin_src emacs-lisp
  (package! competitive-companion
    :recipe (:host github :repo "luishgh/competitive-companion.el"))
#+end_src

** use-package + straight.el

#+begin_src emacs-lisp
  (use-package competitive-companion
    :straight (competitive-companion :type git
                                     :host github
                                     :repo "luishgh/competitive-companion.el"))
#+end_src

* Tutorial

** Initial setup

First, download the [[https://github.com/jmerle/competitive-companion][competitive companion browser extension]] for your favorite (and supported) browser. The extension is the one responsible for reading the problem's information from the webpage.

Now, we need to tell the extension and Emacs to communicate through the same port. For that, add the value of ~competitive-companion-server-port~ to /Custom ports/ in the extension's preference menu. Note you can alter the value of this custom variable if the default port is already being used by something else on your computer.

Now is the perfect time to take a look at the options in [[*Customizing][Customizing]] to make sure the package behaves like you expect. If you don't want to dig the options just yet, please take a quick look at , as they are the ones that must be set correctly for the package to work.

** During a contest

This short tutorial describes the basic usage of the package throughout a typical online contest:

1. Make a folder for the contest and open with ~M-x dired~.
2. Turn on ~competitive-companion-mode~. This automatically selects the current folder as the contest's folder and starts the connection with the browser extension.
3. Open a task page in your browser and click the extension button. The task's implementation file is automatically generated in the contest's folder and test cases are downloaded to temporary files.
4. Code!
5. After compiling your program, run it against all test cases with ~competitive-companion-run-tests~. The outputs buffer uses ~magit-section~, the library that implements the togglable sections of [[https://magit.vc/][Magit]], which means all the bindings you would typically expect on such an interface works! (*Tip*: check all the enabled bindings with ~C-h m~)
6. Get that AC!

*** User Commands

#+findex: competitive-companion-mode
- ~competitive-companion-mode~ :: starts the connection with the browser extension and sets the contest's folder to the value of ~default-directory~.

#+findex: competitive-companion-run-tests
- ~competitive-companion-run-tests~ :: prompts for a program to run against the test case of the current task. The program is run synchronously, so the feedback is showed as soon as your program finishes execution and you can cancel the execution with ~C-g~ if it hangs (which signals an infinite loop or =TLE=). The default value for the prompt is either the last used program if that exists or is automatically generated by the lambda stored at ~competitive-companion-task-filename-generator~. Customize this variable if the default behaviour does not suit you.

#+findex: competitive-companion-toggle-output-buffer
- ~competitive-companion-toggle-output-buffer~ :: switches the cursor to the current task's output buffer in a DWIM fashion. If the buffer does not exist, tries to run ~competitive-companion-run-tests~ with the default value.

*** Important observations

- You need to run ~competitive-companion-run-tests~ while inside the task implementation file's buffer. This helps ~competitive-companion.el~ determine which test cases it should run. You can, however, have multiple binaries (one standard and one compiled with a stress test flag, for example) for the same task and choose which one to run against the test cases.
- You *should not kill a task implementation file's buffer during the contest*. As said above, the package uses buffer local variables to associate a programming file with its test cases directory. If you kill the task buffer after loading its cases, you'll have to use the browser extension to load them again. Your implementation file will be preserved, as is explained below.
- If a file with the automatically generated filename already exists in the contest folder, selecting that task's page with the browser extension only downloads the test cases, opens the file in a buffer and adjusts that buffer's local variables to associate it with the case files.


** Inside the outputs buffer

In the case of your program failing some test case, a special =*competitive-companion-output*= buffer will pop-up. Inside of it, you can navigate with the usual =magit-section= bindings, but you can also add/remove/edit tests cases. In case you want to see the buffer again or open it when all tests pass, you can use the ~competitive-companion-toggle-output-buffer~ command.

To rerun all test cases using the last program you used for that particular task, just execute the ~revert-buffer~ command.

To edit a test case, press ~RET~ while inside its =Input= and =Expected Output= sections. This will open the temporary file on the current buffer. After you are done, just go back to the outputs buffer and revert it to rerun all test cases against the previously used program.

To add a test case, press ~+~ while inside the outputs buffer. This will add a test case with empty input and expected output, which you can edit.

To remove a test case, move the cursor to the test case header and press ~-~. The package will gently stop you if you try to remove original test cases, as this tends to not be a reasonable course of action.

* Customizing

This is a list of the customization options. You can also check them with:

#+begin_example
M-x customize-group RET competitive-companion RET
#+end_example

Note that it can be useful to set some of the options below with Directory Local Variables ([[info:emacs#Directory Variables]]) for a particular contest folder. Maybe you want to use a different programming language, disable automatic filenames, etc. For example, a possible use case is using the package for ladder/list style folders, where you solve problems coming from multiple online judges. In that case, you most probably want to set the file names for the implementation files manually, so you can set ~competitive-companion-prompt-task-filename~ to nil.

** Language/file options

These options refer to setting your programming language of choice and the contents of generated files. They are essential to the workings of the package and are the ones you should be most familiar with.

#+vindex: competitive-companion-task-major-mode
- ~competitive-companion-task-major-mode~ :: Major mode for task's implementation file. The package uses this to insert the template header correctly as comments, to generate the proper name for implementation files, etc. Its value must be one of the mode names present in ~competitive-companion-languages~ and should be a mode that defines *comment syntax*.

#+vindex: competitive-companion-languages
- ~competitive-companion-languages~ :: List of available languages to choose when fetching a new task. Each entry should be of the form ~(MAJOR-MODE . EXTENSION)~ where ~EXTENSION~ is a string indicating a file extension, always starting with a dot.

#+vindex: competitive-companion-task-template-file
- ~competitive-companion-task-template-file~ :: Template file that is used for automatically generated task implementation files. Set to nil to disable this behaviour

#+vindex: competitive-companion-prompt-task-filename
- ~competitive-companion-prompt-task-filename~ :: If non-nil, prompt for a task filename instead of automatically generating one when a task is received from the browser extension. This option must be set *BEFORE* turning on the mode and you need to restart the mode to toggle its value.

#+vindex: competitive-companion-task-filename-generator
- ~competitive-companion-task-filename-generator~ :: Function that generates the task filename based on problem's =NAME=. This is used if ~competitive-companion-prompt-task-filename~ is non-nil. The default behaviour is documented in the variable's docstring and just works on most major online judges, but is not guaranteed to work on all judges as this is essentially impossible.

#+vindex: competitive-companion-insert-header
- ~competitive-companion-insert-header~ :: This boolean option controls whether the package's header is inserted in automatically generated files. It contains basic information about the problem and shares the package's GitHub. Set to nil if this annoys you.

* Function and Command Index
:PROPERTIES:
:APPENDIX:   t
:INDEX:      fn
:END:
* Variable Index
:PROPERTIES:
:APPENDIX:   t
:INDEX:      vr
:END:
* Copying
:PROPERTIES:
:COPYING: t
:END:

 #+begin_quote
Copyright (C) {{{date}}} {{{author}}} <{{{email}}}>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
#+end_quote
 
 
 
 
 
 
